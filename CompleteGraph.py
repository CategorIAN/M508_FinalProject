from itertools import product
import numpy as np
from functools import reduce
import random
class CompleteGraph:
    def __init__(self, dist_matrix):
        '''
        :param dist_matrix: n by n matrix w where w[(i, j)] is the weight of the edge (i, j) and where w[(i, i)] = 0
        '''
        m, n = dist_matrix.shape
        if m != n:
            raise AttributeError("Matrix is Not Square")
        self.n = n
        self.vertices = list(range(self.n))
        self.edges = list(product(range(self.n)))
        self.w = (np.ones((n, n)) - np.eye(n)) * dist_matrix
        self.W = self.w.flatten()
        self.neighbors = dict([(i, set(self.filter(self.vertices, lambda j: j != i))) for i in self.vertices])
        self.N = self.neighbor_matrix()
        self.U = self.getU()


    def closeWalk(self, w):
        '''
        :param w: a list of vertices to walk
        :return: if the beginning vertex is not the end vertex, the walk w with the beginning vertex appended to the end
        '''
        return w + [w[0]] if len(w) > 0 and w[-1] != w[0] else w

    def randomHamCycle(self):
        '''
        :return: a random list of vertices that represent a Hamiltonian cycle of the graph
        '''
        return self.closeWalk(random.sample(range(self.n), k = self.n))

    def walkDistance(self, walk):
        '''
        :param walk: a list of vertices to walk
        :return: the sum of the weights of the edges to walk that corresponds to walking the given list of vertices
        '''
        def recurse(distance, current_v, toWalk):
            if len(toWalk) == 0:
                return distance
            else:
                next_v, remaining = toWalk[0], toWalk[1:]
                return recurse(distance + self.w[(current_v, next_v)], next_v, remaining)
        return 0 if len(walk) == 0 else recurse(0, walk[0], walk[1:])

    def tourDistance(self, S):
        '''
        :param S: a list of vertices that represents a full solution for Q Learning
        :return: the total walk distance of the tour generated by S
        '''
        return self.walkDistance(self.closeWalk(S))

    def filter(self, s, predicate):
        '''
        :param s: list of vertices
        :param predicate: a function that takes a vertex and returns a boolean
        :return: a sublist of s that is filtered by the predicate
        '''
        return reduce(lambda v, i: v + [i] if predicate(i) else v, s, [])

    def neighbor_vec(self, v):
        '''
        :param v: vertex of graph
        :return: a binary vector that gives a 1 at index u if u is a neighbor of v and a 0 otherwise
        '''
        neighbors = self.neighbors[v]
        return np.vectorize(lambda i: int(i in neighbors))(self.vertices).reshape(-1, 1)

    def neighbor_matrix(self):
        '''
        :return: square matrix where the vth column is the neighbor_vec of v
        '''
        return np.concatenate([self.neighbor_vec(v) for v in self.vertices], axis = 1)

    def unit_vec(self, v):
        '''
        :param v: vertex of graph
        :return: a unit vector of the dimension of the number of vertices in the direction of vertex v
        '''
        return np.vectorize(lambda i: int(i == v))(self.vertices).reshape(-1, 1)

    def neighbor_square(self, v):
        '''
        :param v: vertex of graph
        :return: square matrix where the vth column is the neighbor_vec of v and zeros elsewhere
        '''
        return np.outer(self.neighbor_vec(v), self.unit_vec(v).reshape(1, -1))

    def getU(self):
        '''
        :return: a concatenation of each vertex neighbor_square along the 0th axis
        '''
        return np.concatenate([self.neighbor_square(v) for v in self.vertices], axis=0)
